## 非同质化代币

非同质化代币（Non-Fungible Token，NFT）是一种加密货币，与传统加密货币如比特币等有所不同。比特币是等价的，每个比特币在使用过程中没有差异，如果一个比特币能购买一个苹果，那么其他任何一个比特币也能购买一个苹果。相比之下，NFT具有独特的价值，通常用于代表现实世界的资产，如精心创作的艺术品、音乐或电影等。NFT的价值取决于与之关联的资产，例如代表书籍《西游记》的NFT和代表画作《星空》的NFT拥有完全不同的价值。即使是十个代表书籍《西游记》的NFT，由于书籍的新旧、是否经手名人、书籍的批注等信息，它们的价值也可能各不相同。

ERC-721是实现NFT的一套标准。由于每个NFT具有独特的价值，ERC-721提出采用uint256变量来区分每个NFT。此外，NFT需要与资产内容关联，ERC-721提出采用链接的方式将NFT与资产的实际内容关联起来。任何用户都可以访问NFT合约以读取链接，然后通过链接访问到NFT的实际内容。采用链接的方式的优势在于NFT拥有者可以选择任意存储系统来存储资产的实际内容，当然，缺点是NFT拥有者需要承担长期存储NFT实际内容的成本。

### NFT的问题和解决思路

无论NFT拥有者选择何种存储系统保存NFT的实际内容，NFT所有者都需要承担存储NFT的实际内容的费用。若无力承担存储成本，将导致无法访问NFT的实际内容，最终导致NFT价值归零。

当前NFT领域的解决思路主要是通过NFT的高收益来覆盖存储成本，且这一收益必须显著超过存储成本。因此，目前NFT主要用于代表那些拥有高内容价值、但NFT数据副本相对较小的资产，如艺术品、游戏中的道具等。以OpenSea网站上的NFT为例，一个仅有10MB大小的图片售价达到了140美元。

## 数据资产类NFT解决思路

尽管NFT具有代表多种资产的潜力，但由于NFT所有者需要承担数据副本长期存储的存储成本，目前NFT能够代表的资产有限。特别是对于数据资产而言，数据资产的内容价值差异较大。其中包括一些极高价值的数据，如OpenAI的核心数据或代码；一些高价值的数据，如火箭发射期间收集的数据；以及一些低价值的数据，例如个人的行为数据。而且，绝大部分的数据属于低价值数据。当数据的内容价值无法覆盖长期存储成本时，NFT所有者将难以确保数据副本的永久存在。这为NFT领域带来了挑战，需要进一步探索如何有效管理不同价值层次的数据资产。

目前，已有一些项目方如ocean protocol专注于数据资产类NFT。

### Ocean Protocol

Ocean Protocol在NFT的基础上实现了数据共享的功能，从而放大了数据资产的价值。具体而言，Ocean Protocol使用数据NFT代表数据资产的基础版权。用户在Ocean中发布数据集时，需要提供数据集的可访问链接给Ocean中的特殊节点，该节点会返回加密后的链接。随后，用户使用加密后链接、描述信息等创建一个新的数据NFT。用户通过持有私钥，能够证明其拥有该数据集的数据NFT，从而证明其拥有该数据集的基础版权。此外，Ocean Protocol使用数据代币代表数据资产的可访问凭证。数据代币由数据NFT的拥有者发行，其他用户需要从数据NFT的所有者手中购买数据代币。用户通过提供持有数据代币的证明，能够从对应节点中获取解密后的链接，从而获取对应的数据内容。

尽管Ocean Protocol引入了数据代币和额外的访问控制（加解密链接），实现了数据共享的功能，但仍存在一些问题：1）Ocean Protocol引入了特殊节点对链接进行加密，导致用户在访问数据内容时需要同时访问链上合约、Ocean中节点以及存储系统，增加了整个协议中的攻击途径。攻击者不仅可以攻击区块链以及存储系统，还可以攻击Ocean中的节点，导致数据不可访问。2）Ocean Protocol仍采用链接方式关联NFT和数据内容，需要访问链接才能获取数据内容的状态信息。并且链接由Ocean中节点加密，导致除了拥有读取权的用户，其他用户均无法获取到数据内容的状态信息。例如当数据内容过期，但链上NFT任然存在，且基础版权和访问凭证依然在市场中售卖，便会存在用户购买的实际上是无意义的数据。

### 解决思路

Ocean Protocol以及NFT通过链接方式将NFT和数据内容关联。这种方案的优势在于可以自由选择存储系统，但是劣势在于NFT合约无法获取到数据内容的状态信息，尤其是数据内容的有效期。这可能导致数据内容过期，但NFT依然存在的情况，使得对NFT的操作变得无意义。为了解决这一问题，需要支持的存储系统将数据状态信息上链。

为了在NFT合约中直接获取数据内容的状态信息，我们需要额外部署一个维护数据内容状态信息的合约，并且这个合约应该由存储系统维护。为确保数据状态信息真实可信，存储系统需要提供除存储功能外的额外功能。例如，为了证明合约中有效期的真实可信，存储系统需要定期提供数据内容的存储证明，以证明在有效期内，数据一直存在于存储系统中。此外，存储系统需要依赖于NFT合约中的权限信息，以实现对数据内容的访问控制系统。

## 数据资产权限合约设计

### 数据资产组成

数据资产由三部分数据组成：

- 存储元数据：包括哈希，大小，有效期以及上传者地址。由区块链上存储合约保存和维护。
- 权限元数据：包括所有权和读取权的信息，以及规定哪些地址可以修改这些信息。由区块链上权限合约保存和维护。
- 数据内容：用户上传至存储系统的数据。数据内容存储在链下存储节点中。

其中权限合约由以下属性组成。

| 属性名              | 表示方法                               | 用处                                               |
| ------------------- | -------------------------------------- | -------------------------------------------------- |
| tokenId             | uint256                                | 数据资产的编号，区别于其他数据资产                 |
| owner               | map (uint256 => address)               | 数据资产的所有人，有权更改数据资产的信息           |
| reader              | map (uint256=> map (address => bool))  | 数据资产的读取权人，能够从存储系统中获取到数据内容 |
| tokenApproval       | map (uint256 => address)               | 数据资产的代理人，有权更改数据资产的信息           |
| operatorApproval    | map (address => map (address => bool)) | 用户的代理人，有权更改所有属于用户的数据资产的信息 |
| storageContractAddr | address                                | 存储合约的地址                                     |
| tokenHash           | map (uint256 => bytes)                 | 数据资产的哈希值                                   |

### 数据资产权限合约功能描述

数据资产应由所有权人管理，且所有权人应具备以下功能：

```solidity
interface dataPermission {
	function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) external;
	function setReader(address reader, uint256 tokenId) external;
	function approve(address approved, uint256 tokenId) external;
	function setApprovalForAll(address operator, bool approved) external;
	
	function ownerOf(uint256 tokenId) external view returns (address);
	function isReader(uint256 tokenId, address reader) external view returns (bool);
	function getApproved(uint256 tokenId) external view returns (address);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}
```

**safeTransferFrom规则**

- 验证当前时间是否小于`expire`;
- 验证`from`是否等于`msg.sender`，验证`from`是否是`tokenId`的`owner`，`tokenId`的`tokenApproval`或者是`owner`的`operatorApproval`；
- 若`to`是合约地址，需要调用合约地址的函数onERC721Received()，验证合约是否有管理dataAsset的功能，避免传入黑洞地址；
- 将`tokenId`的`owner`修改为`to`；

**setReader规则**

- 验证当前时间是否小于`expire`;
- 验证`msg.sender`是否是`tokenId`的`owner`或者`tokenApproval`；
- 将`reader`添加到`tokenId`的`reader`中；

**approve规则**

- 验证当前时间是否小于`expire`;
- 验证`msg.sender`是否是`tokenId`的`owner`；
- 将`tokenId`的`tokenApproval`修改为`approved`；

**setApprovalForAll规则**

- 验证当前时间是否小于`expire`;
- 验证`msg.sender`是否等于`operator`；
- 将`operator`的`operatorApproval`。

## 存储合约需求

### 获取存储元数据

可以通过文件哈希获取到所有的存储元数据。

### 验证存储证明

验证存储节点提交的存储证明。

## 存储系统需求

#### 上传文件

上传数据分为链上和链下两步：

- 链上交互：首先需要和存储合约交互，选择存储节点，支付费用，上传存储元数据。并由存储合约调用权限合约的mint方法铸造NFT代表文件的所有权；
- 链下交互：与对应的存储节点建立连接，将文件内容上传到存储节点之上。

### 文件存储证明

在文件的有效期内，为了确保文件持久的存储在对应的存储节点之上，需要存储节点定时提交文件的存储证明。

#### 下载文件

文件内容只能拥有访问文件权限的用户才能下载。下载需要和存储网络交互，从对应的存储节点下载完整的文件内容。

### 访问控制

去中心化存储系统中存储节点需要按照链上权限规则实现访问控制。具体而言，存储系统在对用户进行身份认证，并且用户在发送下载请求给存储系统后，存储系统需要验证用户是否有访问该文件的权限，即验证用户是否拥有该文件的所有权和读取权。

#### 付费

去中心化存储系统中费用分为流量费用和存储费用：

- 流量费用：上传文件和下载文件时，用户根据文件大小给相应的存储节点支付的费用；
- 存储费用：存储在存储节点的文件根据文件大小，存储天数支付的费用。因此，存储在存储节点上的文件存在有效期，只有在有效期内，文件才是可访问的。

## 示例

### 示例1

假设在去中心化存储中存在三个账户，Alice，Bob和Carl。

- Alice上传文件file至存储节点；
- Alice授予Bob读取权限；
- Alice将文件file的所有权转让给Carl；
- 此时，Bob持有文件file的读取权，Carl持有文件file的所有权。Bob和Carl均能够从存储节点上获取到文件file；

### 示例2

- Alice上传文件file至存储节点；
- Alice授予Bob读取权限；
- Alice将文件file的所有权转让给Carl；
- 此时文件过期，链上与file相关的功能均不可用。任何人均无法从存储节点上获取到文件。

